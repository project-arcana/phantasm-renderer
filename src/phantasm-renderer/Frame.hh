#pragma once

#include <clean-core/span.hh>
#include <clean-core/string_view.hh>

#include <typed-geometry/tg.hh>

#include <phantasm-hardware-interface/commands.hh>

#include <phantasm-renderer/common/growing_writer.hh>
#include <phantasm-renderer/default_config.hh>
#include <phantasm-renderer/format.hh>

#include <phantasm-renderer/resource_types.hh>

namespace pr
{
class Frame
{
public:
    // pass RAII API

    template <class... RTs>
    void render_to(RTs const&... targets) // TODO return
    {
        phi::cmd::begin_render_pass bcmd;
        // initialize command
        bcmd.set_null_depth_stencil();

        // add targets
        (addRenderTarget(bcmd, targets), ...);

        // flush RT transitions generated by addRenderTarget
        flushPendingTransitions();

        // write begin_render_pass
        mWriter.add_command(bcmd);
    }

    // pipeline RAII API (compute only, graphics pipelines are in pr::Framebuffer

    void pipeline(compute_pipeline_state const& compute_pipeline); // TODO
    // TODO: cache-access version

    // commands

    void copy(buffer const& src, buffer const& dest, size_t src_offset = 0, size_t dest_offset = 0);

    void copy(buffer const& src, image const& dest, size_t src_offset = 0, unsigned dest_mip_index = 0, unsigned dest_array_index = 0);

    void copy(image const& src, image const& dest);

    void resolve(render_target const& src, image const& dest);

    // move-only type
public:
    Frame(Frame const&) = delete;
    Frame(Frame&&) noexcept = default;
    Frame& operator=(Frame const&) = delete;
    Frame& operator=(Frame&&) noexcept = default;

    // internal
private:
    void addRenderTarget(phi::cmd::begin_render_pass& bcmd, render_target const& rt);

    void addPendingTransition(phi::handle::resource res, phi::resource_state target, phi::shader_stage_flags_t dependency = {});
    void flushPendingTransitions();

    // Context-side API
private:
    friend class Context;
    Frame(Context* ctx, size_t size) : mCtx(ctx), mWriter(size) {}

    std::byte* getMemory() const { return mWriter.buffer(); }
    size_t getSize() const { return mWriter.size(); }
    bool isEmpty() const { return mWriter.is_empty(); }

    // members
private:
    Context* mCtx;
    growing_writer mWriter;
    phi::cmd::transition_resources mPendingTransitionCommand;
};
}
